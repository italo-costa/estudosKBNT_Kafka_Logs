# üîÑ WORKFLOW COMPLETO - KBNT VIRTUAL STOCK MANAGEMENT

## üìã Vis√£o Geral do Sistema

O sistema KBNT Virtual Stock Management implementa um **workflow completo de virtualiza√ß√£o de estoque** usando **arquitetura hexagonal**, **microservi√ßos Spring Boot** e **Red Hat AMQ Streams** para processamento de eventos em tempo real.

---

## üèóÔ∏è ARQUITETURA DO WORKFLOW

```mermaid
graph TB
    subgraph "Cliente/Interface"
        UI[Web UI/Mobile App]
        API_GW[API Gateway]
    end
    
    subgraph "Microservi√ßos Spring Boot - Arquitetura Hexagonal"
        subgraph "User Service"
            US_D[Domain Layer]
            US_A[Application Layer] 
            US_I[Infrastructure Layer]
        end
        
        subgraph "Order Service"
            OS_D[Domain Layer]
            OS_A[Application Layer]
            OS_I[Infrastructure Layer]
        end
        
        subgraph "Payment Service"
            PS_D[Domain Layer]
            PS_A[Application Layer]
            PS_I[Infrastructure Layer]
        end
        
        subgraph "Inventory Service"
            IS_D[Domain Layer - Virtual Stock]
            IS_A[Application Layer]
            IS_I[Infrastructure Layer]
        end
        
        subgraph "Notification Service"
            NS_D[Domain Layer]
            NS_A[Application Layer]
            NS_I[Infrastructure Layer]
        end
        
        subgraph "Audit Service"
            AS_D[Domain Layer]
            AS_A[Application Layer]
            AS_I[Infrastructure Layer]
        end
    end
    
    subgraph "Red Hat AMQ Streams (Kafka)"
        TOPIC1[user-events]
        TOPIC2[order-events]
        TOPIC3[payment-events]
        TOPIC4[inventory-events]
        TOPIC5[notification-events]
        TOPIC6[audit-logs]
        TOPIC7[application-logs]
    end
    
    subgraph "Processamento & Analytics"
        CONSUMER[Log Consumer Python]
        PROCESSOR[Event Processor]
        ANALYTICS[Real-time Analytics]
    end
    
    subgraph "Persist√™ncia"
        DB1[(User DB)]
        DB2[(Order DB)]
        DB3[(Payment DB)]
        DB4[(Virtual Stock DB)]
        DB5[(Audit DB)]
    end
    
    subgraph "Monitoramento"
        METRICS[Prometheus Metrics]
        DASHBOARD[Grafana Dashboard]
        ALERTS[Alert Manager]
    end
    
    %% Fluxos principais
    UI --> API_GW
    API_GW --> US_A
    API_GW --> OS_A
    API_GW --> PS_A
    API_GW --> IS_A
    
    %% Comunica√ß√£o entre camadas hexagonais
    US_A --> US_D
    US_D --> US_I
    US_I --> DB1
    US_I --> TOPIC1
    
    OS_A --> OS_D
    OS_D --> OS_I
    OS_I --> DB2
    OS_I --> TOPIC2
    
    PS_A --> PS_D
    PS_D --> PS_I
    PS_I --> DB3
    PS_I --> TOPIC3
    
    IS_A --> IS_D
    IS_D --> IS_I
    IS_I --> DB4
    IS_I --> TOPIC4
    
    NS_I --> TOPIC5
    AS_I --> TOPIC6
    
    %% Processamento de eventos
    TOPIC1 --> CONSUMER
    TOPIC2 --> CONSUMER
    TOPIC3 --> CONSUMER
    TOPIC4 --> CONSUMER
    TOPIC5 --> CONSUMER
    TOPIC6 --> CONSUMER
    TOPIC7 --> CONSUMER
    
    CONSUMER --> PROCESSOR
    PROCESSOR --> ANALYTICS
    ANALYTICS --> DASHBOARD
    
    %% Monitoramento
    US_I --> METRICS
    OS_I --> METRICS
    PS_I --> METRICS
    IS_I --> METRICS
    METRICS --> DASHBOARD
    DASHBOARD --> ALERTS
```

---

## üîÑ FLUXO DETALHADO DO WORKFLOW

### **FASE 1: Recebimento da Requisi√ß√£o**
```
1. Cliente faz requisi√ß√£o ‚Üí API Gateway
2. API Gateway ‚Üí Microservi√ßo apropriado
3. APPLICATION Layer ‚Üí Valida√ß√£o e orquestra√ß√£o
4. DOMAIN Layer ‚Üí Regras de neg√≥cio
5. INFRASTRUCTURE Layer ‚Üí Persist√™ncia + Eventos
```

### **FASE 2: Processamento Hexagonal por Camadas**

#### üéØ **DOMAIN Layer (N√∫cleo de Neg√≥cio)**
```java
// Exemplo: Virtual Stock Domain
@DomainService
public class VirtualStockService {
    
    public VirtualStockReservation reserveStock(ProductId productId, Quantity quantity) {
        // ‚úÖ Regras de neg√≥cio puras
        VirtualStock stock = virtualStockRepository.findByProductId(productId);
        
        if (!stock.canReserve(quantity)) {
            throw new InsufficientStockException();
        }
        
        VirtualStockReservation reservation = stock.reserve(quantity);
        
        // üî• Evento de dom√≠nio
        domainEventPublisher.publish(new StockReservedEvent(productId, quantity));
        
        return reservation;
    }
}
```

#### üì± **APPLICATION Layer (Casos de Uso)**
```java
// Exemplo: Order Processing Use Case
@ApplicationService
public class ProcessOrderUseCase {
    
    public void processOrder(ProcessOrderCommand command) {
        // ‚úÖ Orquestra√ß√£o de opera√ß√µes
        
        // 1. Validar usu√°rio
        User user = userService.validateUser(command.getUserId());
        
        // 2. Reservar estoque virtual
        VirtualStockReservation reservation = virtualStockService
            .reserveStock(command.getProductId(), command.getQuantity());
        
        // 3. Processar pagamento
        PaymentResult payment = paymentService
            .processPayment(command.getPaymentInfo());
        
        // 4. Criar ordem
        Order order = orderService.createOrder(command, reservation, payment);
        
        // üî• Publicar evento
        eventPublisher.publish(new OrderProcessedEvent(order));
    }
}
```

#### üîß **INFRASTRUCTURE Layer (Integra√ß√µes)**
```java
// Exemplo: Kafka Event Publisher
@Component
public class KafkaEventPublisher implements EventPublisher {
    
    @Autowired
    private KafkaTemplate<String, Object> kafkaTemplate;
    
    public void publish(DomainEvent event) {
        // ‚úÖ Publica no AMQ Streams
        String topic = determineTopicFor(event);
        
        EventMessage message = EventMessage.builder()
            .eventId(UUID.randomUUID().toString())
            .eventType(event.getClass().getSimpleName())
            .timestamp(Instant.now())
            .payload(event)
            .hexagonal_layer("infrastructure")
            .operation("event-published")
            .build();
            
        kafkaTemplate.send(topic, message);
        
        // üìä M√©tricas
        meterRegistry.counter("events.published", "topic", topic).increment();
    }
}
```

### **FASE 3: Comunica√ß√£o via AMQ Streams**

#### üìù **T√≥picos e Mensagens**
```yaml
T√≥picos AMQ Streams:
  user-events:        # Eventos de usu√°rio (login, cadastro, etc.)
    - UserRegisteredEvent
    - UserValidatedEvent
    - UserProfileUpdatedEvent
    
  order-events:       # Eventos de pedidos
    - OrderCreatedEvent  
    - OrderProcessedEvent
    - OrderStatusChangedEvent
    
  payment-events:     # Eventos de pagamento
    - PaymentInitiatedEvent
    - PaymentProcessedEvent
    - PaymentFailedEvent
    
  inventory-events:   # Eventos de estoque virtual ‚≠ê
    - VirtualStockReservedEvent
    - VirtualStockReleasedEvent
    - VirtualStockUpdatedEvent
    - LowStockAlertEvent
    
  notification-events: # Eventos de notifica√ß√£o
    - NotificationSentEvent
    - EmailDispatchedEvent
    - SMSDispatchedEvent
    
  audit-logs:         # Logs de auditoria
    - UserActionAuditEvent
    - SystemOperationAuditEvent
    
  application-logs:   # Logs de aplica√ß√£o
    - Logs estruturados de todos os microservi√ßos
```

#### üîÑ **Exemplo de Mensagem Hexagonal**
```json
{
  "eventId": "evt-12345",
  "timestamp": "2025-08-30T15:45:00Z",
  "eventType": "VirtualStockReservedEvent",
  "service": "inventory-service",
  "level": "INFO",
  "hexagonal_layer": "domain",
  "domain": "inventory",
  "operation": "stock-reserved",
  "payload": {
    "productId": "PROD-001",
    "quantity": 5,
    "reservationId": "RES-67890",
    "virtualStockLevel": 95,
    "reservedUntil": "2025-08-30T16:45:00Z"
  },
  "correlationId": "corr-abcdef",
  "metadata": {
    "userId": "user-123",
    "sessionId": "sess-456",
    "source": "inventory-service",
    "version": "1.0"
  }
}
```

### **FASE 4: Consumer e Processamento**

#### üìñ **Log Consumer Python**
```python
class KBNTLogProcessor:
    
    def process_virtual_stock_event(self, event):
        """Processa eventos de estoque virtual"""
        
        if event.get('operation') == 'stock-reserved':
            # ‚úÖ Analisa reserva de estoque
            product_id = event['payload']['productId']
            quantity = event['payload']['quantity']
            stock_level = event['payload']['virtualStockLevel']
            
            # üö® Alerta de estoque baixo
            if stock_level < self.LOW_STOCK_THRESHOLD:
                self.trigger_low_stock_alert(product_id, stock_level)
            
            # üìä M√©tricas em tempo real
            self.update_stock_metrics(product_id, quantity, stock_level)
            
        elif event.get('operation') == 'stock-released':
            # ‚úÖ Processa libera√ß√£o de estoque
            self.handle_stock_release(event)
    
    def process_hexagonal_layer_event(self, event):
        """Processa eventos por camada hexagonal"""
        
        layer = event.get('hexagonal_layer')
        
        if layer == 'domain':
            # üéØ Eventos de dom√≠nio - Alta prioridade
            self.process_domain_event(event)
            
        elif layer == 'application':
            # üì± Events de aplica√ß√£o - Orquestra√ß√£o
            self.process_application_event(event)
            
        elif layer == 'infrastructure':
            # üîß Eventos de infraestrutura - Logs t√©cnicos
            self.process_infrastructure_event(event)
```

---

## üéØ CASOS DE USO PRINCIPAIS

### **Caso 1: Cria√ß√£o de Pedido com Estoque Virtual**

```mermaid
sequenceDiagram
    participant Cliente
    participant API_Gateway
    participant OrderService
    participant InventoryService
    participant PaymentService
    participant AMQ_Streams
    participant LogConsumer
    
    Cliente->>API_Gateway: POST /orders
    API_Gateway->>OrderService: CreateOrderCommand
    
    Note over OrderService: APPLICATION Layer
    OrderService->>OrderService: Validar comando
    
    Note over OrderService: DOMAIN Layer  
    OrderService->>InventoryService: ReserveVirtualStock
    InventoryService->>InventoryService: Verificar disponibilidade
    InventoryService->>AMQ_Streams: VirtualStockReservedEvent
    InventoryService-->>OrderService: StockReservation
    
    OrderService->>PaymentService: ProcessPayment
    PaymentService->>AMQ_Streams: PaymentProcessedEvent
    PaymentService-->>OrderService: PaymentResult
    
    Note over OrderService: INFRASTRUCTURE Layer
    OrderService->>OrderService: Salvar Order
    OrderService->>AMQ_Streams: OrderCreatedEvent
    
    OrderService-->>API_Gateway: OrderResponse
    API_Gateway-->>Cliente: 201 Created
    
    AMQ_Streams->>LogConsumer: Todos os eventos
    LogConsumer->>LogConsumer: Processar e analisar
```

### **Caso 2: Alertas de Estoque Baixo**

```mermaid
sequenceDiagram
    participant InventoryService
    participant AMQ_Streams
    participant LogConsumer
    participant NotificationService
    participant Dashboard
    
    InventoryService->>InventoryService: Verificar n√≠vel de estoque
    
    alt Estoque < Limite M√≠nimo
        InventoryService->>AMQ_Streams: LowStockAlertEvent
        AMQ_Streams->>LogConsumer: Evento recebido
        LogConsumer->>LogConsumer: Processar alerta
        LogConsumer->>NotificationService: TriggerNotification
        NotificationService->>AMQ_Streams: NotificationSentEvent
        LogConsumer->>Dashboard: Atualizar m√©tricas
    end
```

### **Caso 3: Auditoria e Rastreabilidade**

```mermaid
sequenceDiagram
    participant MicroServi√ßo
    participant AMQ_Streams
    participant LogConsumer
    participant AuditService
    participant Dashboard
    
    MicroServi√ßo->>AMQ_Streams: Qualquer evento
    AMQ_Streams->>LogConsumer: Event recebido
    
    LogConsumer->>LogConsumer: Extrair dados de auditoria
    LogConsumer->>AuditService: CreateAuditLog
    AuditService->>AMQ_Streams: AuditLogCreatedEvent
    
    LogConsumer->>Dashboard: Atualizar trilha de auditoria
```

---

## üìä M√âTRICAS E MONITORAMENTO

### **Prometheus Metrics Expostas:**
```yaml
# M√©tricas de Virtual Stock
virtual_stock_reservations_total{product_id, service}
virtual_stock_releases_total{product_id, service}  
virtual_stock_current_level{product_id}
virtual_stock_alerts_total{product_id, alert_type}

# M√©tricas de Microservi√ßos
microservice_requests_total{service, endpoint, method}
microservice_response_time_seconds{service, endpoint}
microservice_errors_total{service, error_type}

# M√©tricas de AMQ Streams
kafka_messages_produced_total{topic, service}
kafka_messages_consumed_total{topic, consumer_group}
kafka_consumer_lag{topic, partition, consumer_group}

# M√©tricas de Arquitetura Hexagonal
hexagonal_layer_operations_total{layer, operation, service}
hexagonal_domain_events_total{domain, event_type}
```

### **Dashboard Grafana:**
```
üéØ Virtual Stock Management Dashboard:
‚îú‚îÄ‚îÄ üìä Stock Levels (Real-time)
‚îú‚îÄ‚îÄ üö® Low Stock Alerts  
‚îú‚îÄ‚îÄ üìà Reservation Trends
‚îú‚îÄ‚îÄ üí∞ Payment Success Rate
‚îú‚îÄ‚îÄ üîÑ Event Processing Rate
‚îú‚îÄ‚îÄ ‚ö° Response Times por Camada
‚îî‚îÄ‚îÄ üèóÔ∏è  Hexagonal Architecture Metrics
```

---

## üî• PONTOS CHAVE DO WORKFLOW

### **1. Separa√ß√£o de Responsabilidades (Hexagonal)**
- **Domain**: L√≥gica de neg√≥cio pura
- **Application**: Orquestra√ß√£o de casos de uso  
- **Infrastructure**: Integra√ß√µes externas

### **2. Event-Driven Architecture**
- Todos os microservi√ßos comunicam via AMQ Streams
- Events s√£o imut√°veis e rastre√°veis
- Processamento ass√≠ncrono e escal√°vel

### **3. Virtual Stock Management**
- Estoque √© virtualizado e gerenciado em tempo real
- Reservas tempor√°rias com TTL
- Alertas autom√°ticos para reposi√ß√£o

### **4. Observabilidade Completa**
- Logs estruturados em JSON
- M√©tricas Prometheus em tempo real
- Rastreamento de transa√ß√µes end-to-end

### **5. Escalabilidade e Resili√™ncia**
- Microservi√ßos independentes
- AMQ Streams com particionamento
- Circuit breakers e retry policies

---

## ‚úÖ RESUMO DO WORKFLOW

**O sistema KBNT implementa um workflow completo de virtualiza√ß√£o de estoque** usando:

1. **üèóÔ∏è Arquitetura Hexagonal** - Separa√ß√£o clara de responsabilidades
2. **üîÑ Event-Driven** - Comunica√ß√£o ass√≠ncrona via AMQ Streams  
3. **üìä Real-time Analytics** - Processamento e monitoramento em tempo real
4. **üéØ Virtual Stock** - Gest√£o inteligente de invent√°rio virtual
5. **üîç Full Observability** - Rastreamento completo de todas as opera√ß√µes

**Status:** ‚úÖ **COMPLETAMENTE IMPLEMENTADO E FUNCIONANDO**
